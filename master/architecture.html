<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Malbolge: Architectural Design and Considerations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Malbolge
   &#160;<span id="projectnumber">0.0.3</span>
   </div>
   <div id="projectbrief">Malbolge virtual machine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Architectural Design and Considerations </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#actor_model">Actor Model</a><ul><li class="level2"><a href="#sync_types">Synchronous and Asynchronous Processing</a></li>
<li class="level2"><a href="#problems">Problems with the Design</a><ul><li class="level3"><a href="#async_getters">Getters become Asynchronous</a></li>
<li class="level3"><a href="#actor_performance">Performance</a></li>
</ul>
</li>
<li class="level2"><a href="#libs">C++ Libraries Used</a><ul><li class="level3"><a href="#asio_lib">Processing Queue</a></li>
<li class="level3"><a href="#signal">Signals/Slots</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#error_handling">Error Handling</a><ul><li class="level2"><a href="#asio_throw">Throwing from Asynchronous Actors</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="actor_model"></a>
Actor Model</h1>
<p>At its core, Malbolge uses the <a href="https://en.wikipedia.org/wiki/Actor_model" target="_blank">Actor Model</a> for concurrency and task management, and signals/slots for notification. </p><div class="image">
<object type="image/svg+xml" data="actor_model.svg" height="400px" style="pointer-events: none;"></object>
</div>
<p> When a method is called on the public API of an actor, the behaviour of the component is not executed immediately, instead a task representing that behaviour is pushed onto a FIFO processing queue and processed once previous tasks have completed.</p>
<p>Because the methods return after pushing the task onto the processing queue, a caller may need another method of being notified when the corresponding task is complete. There are two approaches used in Malbolge depending on the type of notification:</p><ul>
<li>Signals</li>
<li>Per-task Callback</li>
</ul>
<p>Signals (shown in the above diagram) are really just a collection of registered function objects that are all called when the signal is 'fired'. If an external object is interested in being notified of an event, it provides the actor with a function object with the same signature as the signal's type. This function object (a <code>Callable</code> C++ concept) then has its bracket operator called with copies of the signal's arguments used when it was called inside the actor. This process does not involve the processing queue.</p>
<p>Per-task callback is a similar approach, except the that the function object is passed to the actor by the caller as a part of the method call, and is attached to the task as it moves through the processing queue. Ultimately to be called by the task during processing with the result/error/etc.</p>
<p>Fundamentally these approaches are the same, the key difference is that a signal is <em>broadcast</em> - every registered function object is called when a condition is met. Whilst per-task callbacks only pertain to the caller who initiated the task.</p>
<p>A major of advantage of this system is that the actor is completely decoupled from the entities that require notification from it.</p>
<h2><a class="anchor" id="sync_types"></a>
Synchronous and Asynchronous Processing</h2>
<p>This pattern obviously lends itself to asynchronous processing, specifically that the processing of the queue is done in a dedicated thread (indeed this is how the vCPU works). In this case the pushing/popping of tasks onto/off of the processing queue is protected by a mutex - there are no other synchronisation primitives in use.</p>
<p>A complexity comes when handling slots (the registered callbacks used by the signalling system), as the slots will all be called from the processing queue's thread. This is handled in Malbolge by relying on the slot to perform any thread safety actions, as only it knows what concurrency strategy is being used by the caller. As all the main components in Malbolge use the actor model, this is simply a case of the slot pushing a task onto its own processing queue.</p>
<p>However, it is not a requirement that this pattern is asynchronous. Indeed other components are synchronous because the lifetime of their processing queue is the lifetime of the application.</p>
<h2><a class="anchor" id="problems"></a>
Problems with the Design</h2>
<h3><a class="anchor" id="async_getters"></a>
Getters become Asynchronous</h3>
<p>Unless you are happy with the concurrency pattern becoming ugly (or just plain breaking!), adding extra synchronisation primitives outside of the processing queue is a bad idea. But that would be the only way to safely extract state data from an actor.</p>
<p>More importantly, the result of getter becomes undefined as it is not apparent externally what tasks have been completed. A concrete example of this is in a unit test, imagine this sequence of events:</p><ol type="1">
<li>method1 called</li>
<li>method2 called</li>
<li>getter called The getter's result is either useless because processing hasn't started (synchronous processing queue), or unpredictable (asynchronous).</li>
</ol>
<p>Malbolge solves this by using using per-task callbacks (described in <a class="el" href="architecture.html#actor_model">Actor Model</a>). Because the 'getter callback' is associated with a task, the result is acquired synchronised. In the example above, the result is acquired <em>after</em> method2's task has been executed.</p>
<p>The diagram below shows this process. </p><div class="image">
<object type="image/svg+xml" data="per_task_callback.svg" height="300px" style="pointer-events: none;"></object>
</div>
<p> A task has been executed in the caller resulting in one of the actor's per-task callback methods being called (red line). The callback passed to the actor pushes a task onto the caller's processing queue when executed (blue line). Neither entity is blocked waiting for the other.</p>
<h3><a class="anchor" id="actor_performance"></a>
Performance</h3>
<p>The management of the registered slots and the processing queue is not free, it consumes both clock cycles and memory. This is especially evident in the virtual CPU, where every instruction is its own task in the processing queue.</p>
<p>So why use it? Because it makes the code <em>much</em> simpler to understand, <em>much</em> easier to debug, and <em>much</em> safer. Malbolge programs are typically tiny, so the performance of the vCPU is less of a concern.</p>
<h2><a class="anchor" id="libs"></a>
C++ Libraries Used</h2>
<h3><a class="anchor" id="asio_lib"></a>
Processing Queue</h3>
<p>Boost.Asio is used for the processing queue (i.e. an <code>io_context</code>). It is production-proven, and is currently working its way into the C++ standard library (<a href="https://www.boost.org/doc/libs/1_75_0/doc/html/boost_asio/std_executors.html" target="_blank">"executors"</a>). It is also header-only, making integration simpler.</p>
<p>The Boost library suite is available at <a href="https://www.boost.org/">https://www.boost.org/</a>.</p>
<h3><a class="anchor" id="signal"></a>
Signals/Slots</h3>
<p>Although Boost has very good signals support in the form of Boost.Signals2, the version Boost this project targets does not support compiling in C++20 due to iterator API changes in the latest standard. So we have our own simpler version in the form of <a class="el" href="classmalbolge_1_1utility_1_1signal.html">malbolge::utility::signal</a>.</p>
<h1><a class="anchor" id="error_handling"></a>
Error Handling</h1>
<p>Malbolge makes extensive use of two primary types of error condition:</p><ol type="1">
<li>Exceptions</li>
<li><code>std::optional</code></li>
</ol>
<p>Which to use depends on the seriousness of the error condition. The stack unwinding resulting from throwing an exception is <em>very</em> expensive, so should only be done in exceptional circumstances - in Malbolge that is defined as something that would stop program execution within in the vCPU or prevent the program being ran in the first place (e.g. a syntax error). If the error condition does not meet this expectation, then the error should just be logged.</p>
<p><code>std::optional</code> is useful when implemented a small function that processes some input to give an output, but the input could be malformed in some way. The small function may be used in multiple contexts where at least one should not stop vCPU execution, and so exceptions are not suitable. In this case it is up to the caller to check the return and respond accordingly.</p>
<p>All exceptions thrown from Malbolge's code is derived from <a class="el" href="namespacemalbolge.html#a0257eac1a8c518ea2a7730867ff7ca9d">malbolge::basic_exception</a>.</p>
<h2><a class="anchor" id="asio_throw"></a>
Throwing from Asynchronous Actors</h2>
<p>Exceptions contain crucial information about the scenario that caused them to throw, however exceptions cannot cross thread boundaries which poses a problem for asynchronous actors. Without something special, the best you can do is catch the thrown exception in the thread and log the error - but what if clients of that actor need notifying of an error state?</p>
<p>This solved by creating a <code>std::exception_ptr</code> from the thrown exception and passing it to a signal. This way any interested party can rethrow the exception in a way that is safe and useful for them, and the actor originally throwing the exception can safely close down too. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
